# coding=utf-8
'''1. На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет
аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих
реализаций
Python example:
def isEven(value): return value%2==0
-----------
Минус данного исполнения, как мне кажется, в том, что при проверке больших чисел оператору % придется как-то 
неприятно работать с этим большим числом ради проверки на чётность. Плюс может быть в том, что это исполнение 
очевидно и просто для понимания
'''

def is_even_new(num):
    return not int(bin(num)[-1])

'''Здесь плюс в том, что при проверке большого числа, мы не производим дорогих математических операций.
Просто смотрим на конец двоичного представления. Минус может быть в том, что приходиться создавать дополнительный
объект строки и переводить из десятичного представления в двоичное. Можно постараться уйти от перевода большого 
числа в двоичное, и сперва сократить десятичное число, т.к. нам нужна только его последняя цифра:'''

def is_even_new_new(num):
    return not int(bin(int(str(num)[-1]))[-1])

'''Но тогда мы сделаем как минимум 4 новых объекта для определения чётности

----------------------------------------------------------------------------------------

2. На языке Python (2.7) реализовать минимум по 2 класса реализовывающих циклический буфер FIFO.
Объяснить плюсы и минусы каждой реализации.
-----------
Для начала напишем класс для создания кольцевого буфера без перезаписи данных поверх несчитанных 

Добавим в него атрибутами самого буфера, его длины, которую будем запрашивать при создании объекта, указателями на точку записи и точку чтения
'''

class CircularBufferWithoutOverwrite:

    def __init__(self, length):
        self.length = length
        self.buffer = [None] * length
        self.head = 0
        self.tail = 0

# Сделаем проверки на заполненность и пустоту буфера.
    
    def is_full(self):
        return self.buffer[self.head] is not None

    def is_empty(self):
        return self.buffer[self.head - 1] is None

# Метод put записывает данные в буфера по указателю head и смещает указатель.

    def put(self, item):
        if self.is_full():
            print('buffer is full')
            return
        self.buffer[self.head] = item
        if self.head == self.length - 1:
            self.head = 0
        else:
            self.head += 1

# Метод get забирает элемент из буфера по указателю tail, записывает None на его место и сдвигает указатель tail.

    def get(self):
        if self.is_empty():
            print('buffer is empty')
            return
        item, self.buffer[self.tail] = self.buffer[self.tail], None
        if self.tail == self.length - 1:
            self.tail = 0
        else:
            self.tail += 1
        return item

'''Плюсы данной реализации в том, что никакие данные не будут потеряны
Минус  в том, что если скорость чтения опережает скорость записи, то процессу отправляющему данные придётся ждать.
Либо нам нужно создавать дополнительный буфер в виде очереди, чтобы хранить в нём ещё незаписанные данные

Теперь напишем класс для кольцевого буфера с перезаписью данных с теми же атрибутами'''

class CircularBufferWithOverwrite:

    def __init__(self, length):
        self.buffer = [None] * length
        self.length = length
        self.head = 0
        self.tail = 0

    def is_empty(self):
        return self.buffer[self.head - 1] is None

# Проверку на заполненность не делаем, т.к. буфер будет сам себя перезаписывать
# Основное изменение в методе put, что мы добавляем условие для вызова метода tail_shift,
# чтобы сдвинуть tail на актуальный первый элемент при перезаписи данных '''

    def put(self, item):
        self.buffer[self.head] = item
        if self.tail == self.head and self.buffer[self.head - 1] is not None:
            self.tail_shift()
        if self.head == self.length - 1:
            self.head = 0
        else:
            self.head += 1

    def get(self):
        if self.is_empty():
            return 'buffer is empty'
        item, self.buffer[self.tail] = self.buffer[self.tail], None
        self.tail_shift()
        return item

    def tail_shift(self):
        if self.tail == self.length - 1:
            self.tail = 0
        else:
            self.tail += 1

''' Плюс данной реализации в том, что процессу отправляющему данные не придётся останавливаться или отправлять
данные в пустоту. Нам же не нужно реализовывать дополнительные очереди  

Минус в том, что если процесс отправки данных работает быстрее, чем тот, который их забирает,
то мы будем терять данные.
Возможно эти и происходит, когда при передаче сетевых данных теряются пакеты 

-----------------------------------------------------------------------------------------------

3. На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив
чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить
почему вы считаете, что функция соответствует заданным критериям.
------------
Сперва подумал написать быструю сортировку. Но мы ничего не знаем про массив, и он может быть абсолютно любым.
Исходя из этого, подобрать самый эффективный алгоритм сортировки, наверное, даже невозможно.
Поэтому ниже написан алгоритм сортировки слиянием. Он, конечно, немного долгий, из-за того, что работает напролом
по всему массиву. И при многих случаях он будет уступать той же быстрой сортировке (особенно если ей повезёт
с опорным элементом или мы его очень грамотно выберем, зная особенности массива). Но сортировка слиянием стабильно
отработает за O(n logn), и в данном случае, когда мы ничего не знаем про массив, по-моему это хороший выбор.

Разделим алгоритм на две функции
Функция merge_sort будет делить массив пополам индексами массива, и вызывать саму себя от своих половин в функции merge,
пока длина половины не станет равной 1, тогда начнётся сборка отсортированного массива функцией merge

Функция merge будет на каждом вызове из merge_sort собирать новый отсортированный список из переданных ей участков 
массива и возвращать его.
'''

def merge_sort(lst, start, end):
    if start < end:
        mid = (start + end) // 2
        return merge(merge_sort(lst, start, mid), merge_sort(lst, mid + 1, end))
    else:
        return [lst[start]]


def merge(lst1, lst2):
    sorted_part = []
    j = 0
    for i in range(len(lst1)):
        while j != len(lst2):
            if lst1[i] > lst2[j]:
                sorted_part.append(lst2[j])
                j += 1
            else:
                break
        sorted_part.append(lst1[i])
    sorted_part += lst2[j:]
    return sorted_part
