# coding=utf-8
"""1. На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет
аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих
реализаций
Python example:
def isEven(value): return value%2==0
-----------
Минус данного исполнения, как мне кажется, в том, что при проверке больших чисел оператору % придется как-то
неприятно работать с этим большим числом ради проверки на чётность. Плюс может быть в том, что это исполнение
очевидно и просто для понимания

Изначально я отправил Вам этот вариант:
def is_even_new(num):
    return not int(bin(num)[-1])

UPDATE: Есть ещё идея, как использовать двоичное представление числа, и скорее всего использовать более дешево.
Использовать битовую логику, оператор AND:
"""


def is_even_new(num):
    return not num & 1

"""
2. На языке Python (2.7) реализовать минимум по 2 класса реализовывающих циклический буфер FIFO.
Объяснить плюсы и минусы каждой реализации.
-----------
Для начала напишем класс для создания кольцевого буфера без перезаписи данных поверх несчитанных 

Добавим в него атрибуты самого буфера, его длины, которую будем запрашивать при создании объекта,
указателями на точку записи и точку чтения.

UPDATE: Изначально я прислал Вам свою реализацию с заполнением буфера None при инициализации, 
и дальнейшей частичной логикой работы буфера от его заполненности None, не предположив, 
что в него может прилететь None на put и сломать логику.

Переписал классы обоих буферов с инициализацией с пустым списком. Т.к. использовать pop(0)
на каждом вызове get() очень дорого, то реализовал логику буфера через счётчик несчитанных элементов.

Так же напишем исключения для заполненности и пустоты буфера. 
"""


class BufferFull(Exception):
    def __init__(self, text):
        self.txt = text


class BufferEmpty(Exception):
    def __init__(self, text):
        self.txt = text

        
class CircularBufferWithoutOverwrite:

    def __init__(self, length):
        self.length = length
        self.buffer = []
        self.head = 0
        self.tail = 0
        self.count = 0

    # Сделаем проверки на возможность записи и на наличие объектов для чтения.

    def is_full(self):
        return self.count == self.length

    def is_empty(self):
        return not self.count

    # Метод put записывает данные в буфер по указателю head и смещает указатель
    # Если положить в буфер не можем, прокидывается ошибка.

    def put(self, item):
        if self.is_full():
            raise BufferFull('buffer is full')
        if len(self.buffer) < self.length:
            self.buffer.append(item)
        else:
            self.buffer[self.head] = item
        self.count += 1
        if self.head == self.length - 1:
            self.head = 0
        else:
            self.head += 1

    # Метод get возвращает элемент из буфера по указателю tail и сдвигает указатель tail.
    # Если взять из буфера нечего, прокидывается ошибка.

    def get(self):
        if self.is_empty():
            raise BufferEmpty('buffer is empty')
        item = self.buffer[self.tail]
        self.count -= 1
        if self.tail == self.length - 1:
            self.tail = 0
        else:
            self.tail += 1
        return item

'''Плюсы данной реализации в том, что никакие данные не будут потеряны
Минус в том, что если скорость чтения опережает скорость записи, то процессу отправляющему данные придётся ждать.
Либо нам нужно создавать дополнительный буфер в виде очереди, чтобы хранить в нём ещё незаписанные данные

Теперь напишем класс для кольцевого буфера с перезаписью данных с теми же атрибутами
Проверку на заполненность не делаем, т.к. буфер будет сам себя перезаписывать
Основное изменение в методе put, что мы добавляем условие для вызова метода tail_shift,
чтобы сдвинуть tail на актуальный первый элемент при перезаписи данных 
'''


class CircularBufferWithOverwrite:

    def __init__(self, length):
        self.buffer = []
        self.length = length
        self.head = 0
        self.tail = 0
        self.count = 0

    def is_empty(self):
        return not self.count

    def put(self, item):
        if len(self.buffer) < self.length:
            self.buffer.append(item)
        else:
            self.buffer[self.head] = item
        if self.count < self.length:
            self.count += 1
        else:
            self.tail_shift()
        if self.head == self.length - 1:
            self.head = 0
        else:
            self.head += 1

    def get(self):
        if self.is_empty():
            raise BufferEmpty('buffer is empty')
        item = self.buffer[self.tail]
        self.count -= 1
        self.tail_shift()
        return item

    def tail_shift(self):
        if self.tail == self.length - 1:
            self.tail = 0
        else:
            self.tail += 1


''' Плюс данной реализации в том, что процессу отправляющему данные не придётся останавливаться или отправлять
данные в пустоту. Нам же не нужно реализовывать дополнительные очереди  

Минус в том, что если процесс отправки данных работает быстрее, чем тот, который их забирает,
то мы будем терять данные.
Возможно эти и происходит, когда при передаче сетевых данных теряются пакеты 

-----------------------------------------------------------------------------------------------

3. На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив
чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить
почему вы считаете, что функция соответствует заданным критериям.
------------
Сперва подумал написать быструю сортировку. Но мы ничего не знаем про массив, и он может быть абсолютно любым.
Исходя из этого, подобрать самый эффективный алгоритм сортировки, наверное, даже невозможно.
Поэтому ниже написан алгоритм сортировки слиянием. Он отработает напролом по всему массиву.
И при многих случаях он будет уступать той же быстрой сортировке (особенно если ей повезёт
с опорным элементом или мы его очень грамотно выберем, зная особенности массива). Но сортировка слиянием стабильно
отработает за O(n logn), и в данном случае, когда мы ничего не знаем про массив, по-моему это хороший выбор.

UPDATE:
Фидбек был, что программа содержит ошибку.
Вероятно, она была в том, что функция не работала с пустым списком. Исправил это

Изначально я разделил сортировку на две функции. И в решении была возможность сделать сортировку 
определенного участка массива.
Сейчас я переписал всё в одну функцию. 
И убрал возможность сортировки только выбранного участка массива. Теперь сортирует весь массив безальтернативно.
'''


def merge_sort(lst):
    if len(lst) <= 1:
        return lst
    mid = len(lst) // 2
    left_part = merge_sort(lst[:mid])
    right_part = merge_sort(lst[mid:])
    sorted_part = []
    j = 0
    for i in range(len(left_part)):
        while j != len(right_part):
            if left_part[i] > right_part[j]:
                sorted_part.append(right_part[j])
                j += 1
            else:
                break
        sorted_part.append(left_part[i])
    sorted_part += right_part[j:]
    return sorted_part
